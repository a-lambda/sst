---
title: "Données SST du 1er janvier 2025"
format: html
editor_options: 
  chunk_output_type: console
---

## All required functions in this qmd file

```{r}
#| label: functions_definitions_for_that_qmd_file

#------------------- functions definition --------------------------------------

# I want have all the packages installed whose names belong to a vector
install_pkg_not_installed <- function(pkg) {

  pkg_not_installed <- pkg[!(pkg %in% rownames(installed.packages()))]
  install.packages(pkg_not_installed)

}

# I want to load all necessary packages from their names that belong to a vector
load_pkg <- function(pkg) {

  invisible(lapply(pkg, FUN = library, character.only = TRUE))

}

# I want to know how many dimensions are included in the ncdf file
nc_get_dim_qty <- function(nc_file) { return(nc_file$ndims) }

# I want to get the names of all dimensions in the ndcf file
nc_get_dim_names <- function(nc_file) {
  
  n <- nc_get_dim_qty(nc)
  dim_names <- sapply(1:n, \(x) nc_file$dim[[x]]$name)
  return(dim_names)
  
}

# I want to know which units are used for every dimension in the ncdf file 
nc_get_dim_units <- function(nc_file) {
  
  dim_names <- nc_get_dim_names(nc_file)
  dim_units <- sapply(dim_names, \(x) ncatt_get(nc_file, x, "units")$value)
  return(dim_units)
  
}

# I just group names and units dimensions info from the ncdf file into a tibble
nc_get_dim_info <- function(nc_file) {
  
  return(tibble(name = nc_get_dim_names(nc_file), 
                unit = nc_get_dim_units(nc_file)))

}

# I want to get data linked to a variable name from a ncdf file
# Variable name is assigned to the symbol variable that references data
# Example : 
# after executing nc_get_var_date("lon", nc), lon (symbol) contains asked data
nc_get_var_data <- function(var, nc_file) {
  
  ncvar_data <- ncvar_get(nc = nc_file, varid = var )
  envir <- globalenv()
  assign(var, ncvar_data, envir = envir)

}

#-------------------------------------------------------------------------------

```

## Exploration du fichier NetCDF

Il est possible de trouver de plus amples informations sur le traitement des fichiers netCDF avec R [@netcdfi]

```{r}
#| label: install_and_load_packages
#| message: false
#| code-fold: true

pkg <- c("ncdf4", "tidyverse", "terra", "sf", "gt")
install_pkg_not_installed(pkg)
load_pkg(pkg)

```

La connexion au fichier NetCDF s'opère via la commande nc_open.

Grâce à elle nous pouvons déjà voir quel type d'informations sont enregistrées.

```{r}
#| label: load_nc_data_for_example
#| message: false

nc <- nc_open("DATA/RAW/oisst-avhrr-v02r01.20250101.nc")

```

### Les dimensions

les variables principales sont discriminées suivant plusieurs dimensions.

```{r}
#| label: get_dimensions_info
#| message: false
#| code-fold: true


#-------------------------------------------------------------------------------

tib_dim_info <- nc_get_dim_info(nc)

tib_dim_info |> 
  gt() |> 
  tab_header(
    title    = md("**Nom et unités des dimensions**"),
    subtitle = md(paste("(fichier :", basename(nc$filename), ")"))
  ) 

# I want get all considered variable names reference data with same symbol name
walk(nc_get_dim_names(nc), nc_get_var_data, nc_file = nc)

```

Ici, ce sont :

-   lon : la longitude (de taille $1440=\frac{360}{0.25}$)
-   lat : la latitude (de taille $720=\frac{180}{0.25}$)
-   zlev : La hauteur de la surface de l'eau de mer
-   time : temps central de la journée

::: {.callout-note collapse="false"}
-   Les longitudes sont ordonnées de l'Est vers l'Ouest en partant du méridien de Greenwich depuis la valeur $0.125$ jusqu'à la valeur $0.125+1439*0.25=359.875$

-   Les latitudes sont ordonnées du Sud au Nord dans l'array `lat` en partant du pôle Sud depuis la valeur $-90+0.125=-89.875$ jusqu'à la valeur $-89.875+719*0.25=89.875$
:::

Il est possible d'avoir accès aux données des dimensions via la fonction `ncvar_get` et l'accès aux attributs avec la fonction `ncatt_get`

```{r}

time_as_date <- as.Date(time, origin = "1978-01-01 12:00:0", tz = "UTC")

```

### Les variables principales

Nous avons quatre variables stockées dans le fichier :

-   sst : la température quotidienne de la surface de l'eau
-   anom : les anomalies quotidiennes de température de surface de l'eau
-   err : estimated error standard deviation of analysed_sst
-   ice : la concentration en glace

```{r}
#| label: info_variables
(nc_var <- names(nc$var))

# get info about variable attribute
get_var_attribute <- function(var, attribute) {
  nc_var <- names(nc$var)
  if (!(var %in% nc_var)) {
    message(paste("la variable", var, "est inexistante"))
  } else {
  ln <- ncatt_get(nc, var, attname = attribute)
  ifelse(ln$hasatt, ln$value, paste("pas d'attribut ", attribute))
  }
}

# long names
get_var_long_name <- function() {
  vapply(
  nc_var, 
  get_var_attribute, 
  FUN.VALUE = character(1), 
  "long_name"
  )
}
((get_var_long_name()))

# source
get_var_units <- function() {
  vapply(
  nc_var, 
  get_var_attribute, 
  FUN.VALUE = character(1), 
  "units"
  )
}
((get_var_units()))

# fill value
get_var_fill_value <- function() {
  vapply(
  nc_var, 
  get_var_attribute, 
  FUN.VALUE = numeric(1), 
  "_FillValue"
  )
}
((get_var_fill_value()))

```

### Les attributs globaux du fichier

```{r}
#| label: info_attributs_globaux
att <- c("title", "institution", "source", "references", "history", "Conventions") 
get_global_attribute <- function(att) {
  ncatt_get(nc, 0, att)$value
}
(global_attributes <- vapply(att, get_global_attribute, FUN.VALUE = character(1)))

```

## Exploration des variables

```{r}
#| label: load_variables

nc_var <- names(nc$var)

nc_charge_var <- function(var) {
  nc_var <- ncvar_get(nc = nc, varid = var )
  envir <- globalenv()
  assign(var, nc_var, envir = envir)
}

walk(nc_var, nc_charge_var)

```

La variable sst est enregistrée en tant que `r class(sst)` avec les dimensions `r dim(sst)`

-   La longitude correspond à la 1ère dimension (lignes de la matrice)

-   La latitude correspond à la 2ème dimension (colonnes de la matrice)

-   Le vecteur associé est obtenu en parcourant d'abord les 1440 longitudes d'un parallèle avant de passer à la latitude suivante.

```{r}
#| label: conversion_to_dataframe
lonlat <- expand.grid(lon, lat)
df_sst <- cbind(lonlat, as.vector(sst))
names(df_sst) <- c("lon", "lat", "sst")
head(df_sst)

```

## Affichage de la carte des données sst

Avec positionnement en rouge du point de test donné en exemple :

```{r}
#|label: plot_sst

df_sst |> 
  ggplot(aes(x = lon, y = lat, color = sst)) + 
  geom_point(size = 0.5) +
  coord_fixed(expand = FALSE) +
  scale_colour_distiller(palette = "RdBu") +
  labs(
    x = NULL,
    y = NULL,
    title = "Sea Surface Temperature",
    subtitle = time_as_date,
    caption = "Dataset: NOAA OISST V2.1",
    color = "°C"
  )
```

## Calcul de moyenne globale

Il semble qu'il faille appliquer un poids fonction de $\alpha$ en radians pour pondérer les mesures de surface en fonction de la latitude considérée.

Pour calculer ces poids j'ai construit tous les polygones "carrés" de 0.25° de côté suivant un même méridien.

Ces polygones ont pour centre les coordonnées (longitude et latitude) de la mesure SST correspondante.

J'ai ensuite calculé les aires de ces polygones avec le système de coordonnées de référence EPSG:4326 (WGS84).

Les poids relatifs à chaque mesure ont été fixés comme étant les ratio des aires obtenues avec celle de la plus grande aire (aire du polygone situé à l'équateur).

### Calcul des poids à affecter aux mesures suivant la latitude associée

```{r}
#| label: calculate_geo_squares_weights

# fonction génératrice de "carré géographique" de n degrés de côté
# le point de base (lon, lat) est le point inférieur gauche. 

get_geo_square <- function(lon, lat, alpha) {
  
  points <- list(
    matrix(
      c(lon, lat,
        lon + alpha, lat,
        lon + alpha, lat + alpha,
        lon, lat + alpha,
        lon, lat),
      ncol = 2,
      byrow = TRUE
    )
  )
  st_polygon(points)
  
}

get_geo_squares_sf <- function(lon = 0) {
  
  seq(-90, 89.75, by = 0.25) |>
  map(\(x) get_geo_square(lon = lon, lat = x, alpha = 0.25)) |> 
  st_sfc(crs = "EPSG:4326") |> 
  st_as_sf()
  
}

# polygone_sf_world <- seq(0, 359.75, by = 0.25) |> 
#   map(get_polygone_sf) |> 
#   data.table::rbindlist() |> 
#   st_as_sf()

squares_sf <- get_geo_squares_sf()
area_weights <- as.numeric(st_area(squares_sf) / max(st_area(squares_sf)))

tib_area_weights <- as_tibble(area_weights)
names(tib_area_weights) <- c("w")
write_csv2(tib_area_weights, 
           file = "DATA/area_weights")

```

```{r}
#| label: weighted_mean_sst

df_area_weights <- expand.grid(lon, area_weights)
names(df_area_weights) <- c("lon", "w")
w <- df_area_weights$w
df_sst_weights <- cbind(df_sst, w)

# moyenne pondérée globale
sst_weighted_mean <- df_sst_weights |> 
  summarize(wm_sst = weighted.mean(sst, w, na.rm = TRUE))
sst_weighted_mean

# moyenne pondérée entre -60°S et +60°N
df_sst_60S_60N <- df_sst_weights |> 
  filter(lat >= -60 & lat <= 60)
sst_weighted_mean_60S_60N <- df_sst_60S_60N |> 
  summarize(wm_sst_60S_60N = weighted.mean(sst, w, na.rm = TRUE))
sst_weighted_mean_60S_60N

```

Si nous souhaitons centrer la carte sur le méridien de Greenwich, il est nécessaire de translater les longitudes.

```{r}
#|label: plot_sst_greenwich

df_sst |> 
  mutate(lon = if_else(lon > 180, lon - 360, lon)) |> 
  ggplot(aes(x = lon, y = lat, fill = sst)) + 
  geom_raster() +
  scale_fill_gradient2(
    low = "darkblue",
    mid = "white",
    high = "darkred",
    midpoint = 15
  ) +
  coord_fixed(expand = FALSE) +
  #scale_colour_distiller(palette = "RdBu") +
  labs(
    x = NULL,
    y = NULL,
    title = "Sea Surface Temperature",
    subtitle = paste0(
      time_as_date,
      " - mean global = ",
      round(sst_weighted_mean, 2),
      " °Celsius",
      " | ",
      " mean World(60°S-60°N) = ",
      round(sst_weighted_mean_60S_60N, 2),
      " °Celsius"
    ),
    caption = "Dataset: NOAA OISST V2.1",
    fill = "°C",
  ) +
  theme(
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    # panel.background = element_rect(fill = "black"),
    # plot.background = element_rect(fill = "black")
  )

```
